<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Board Game</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        #game-container {
            display: flex;
            width: 95%;
            height: 95%;
        }
        #players-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 10px;
            width: 15%;
            background-color: #f4f4f4;
            border-right: 1px solid #ccc;
        }
        #player-controls {
            margin-bottom: 10px;
            width: 100%;
        }
        .player-slot {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 10px;
            padding: 10px;
            width: 100%;
            border: 1px solid #ccc;
            background-color: #fff;
        }
        .player-icon {
            width: 50px;
            height: 50px;
            margin-bottom: 5px;
        }
        .player-status {
            margin-bottom: 5px;
        }
        .player-cards, .player-lp {
            margin-bottom: 5px;
        }
        #main-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex-grow: 1;
        }
        #controls {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 10px;
        }
        button, input {
            margin: 5px;
        }
        #board-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            flex-grow: 1;
            width: 100%;
        }
        #snackbar {
            visibility: hidden;
            min-width: 250px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 2px;
            padding: 16px;
            position: fixed;
            z-index: 1;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 17px;
        }
        #snackbar.show {
            visibility: visible;
            animation: fadein 0.5s, fadeout 0.5s 2.5s;
        }
        @keyframes fadein {
            from {top: 0; opacity: 0;}
            to {top: 30px; opacity: 1;}
        }
        @keyframes fadeout {
            from {top: 30px; opacity: 1;}
            to {top: 0; opacity: 0;}
        }
        #board {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            grid-template-rows: repeat(6, 1fr);
            gap: 2px;
            width: 50vmin;
            height: 50vmin;
            margin-top: 20px;
        }
        .slot {
            border: 1px solid #000;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f0f0f0;
            position: relative;
        }
        .highlight {
            background-color: yellow !important;
        }
        .deck-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 10px;
        }
        .deck-label {
            margin-bottom: 5px;
            font-weight: bold;
        }
        .deck-card {
            width: 60px;
            height: 90px;
            border: 1px solid #000;
            background-color: gray;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            color: white;
            cursor: grab;
        }
        .hand-container {
            display: flex;
            align-items: center;
            margin-top: 20px;
            width: 100%;
            justify-content: center;
        }
        .hand {
            border: 1px solid #000;
            padding: 10px;
            width: 50%;
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-start;
            min-height: 120px;
        }
        .card {
            width: 60px;
            height: 90px;
            border: 1px solid #000;
            background-color: white;
            margin: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
        }
        .card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        #dice-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            background-color: #f4f4f4;
            border-left: 1px solid #ccc;
            width: 15%;
        }
        #dice-result {
            font-size: 20px;
            margin-top: 10px;
        }
        #roll-history {
            margin-top: 10px;
            width: 100%;
            text-align: center;
        }
        #decks {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 20px;
        }
        .skill-deck-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-left: 20px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="players-info">
            <div id="player-controls">
                <button id="startHost">Start as Host</button>
                <input type="text" id="peerId" placeholder="Enter Host ID">
                <button id="joinGame">Join Game</button>
                <div id="hostIdDisplay"></div>
            </div>
            <div id="player1" class="player-slot">
                <img src="images/no-player.png" class="player-icon" alt="No Player">
                <div class="player-status">Disconnected</div>
                <div class="player-cards">Cards: 0</div>
                <div class="player-lp">LP: 0</div>
            </div>
            <div id="player2" class="player-slot">
                <img src="images/no-player.png" class="player-icon" alt="No Player">
                <div class="player-status">Disconnected</div>
                <div class="player-cards">Cards: 0</div>
                <div class="player-lp">LP: 0</div>
            </div>
            <div id="player3" class="player-slot">
                <img src="images/no-player.png" class="player-icon" alt="No Player">
                <div class="player-status">Disconnected</div>
                <div class="player-cards">Cards: 0</div>
                <div class="player-lp">LP: 0</div>
            </div>
            <div id="player4" class="player-slot">
                <img src="images/no-player.png" class="player-icon" alt="No Player">
                <div class="player-status">Disconnected</div>
                <div class="player-cards">Cards: 0</div>
                <div class="player-lp">LP: 0</div>
            </div>
        </div>
        <div id="main-area">
            <div id="board-container">
                <div id="snackbar"></div>
                <div id="board"></div>
            </div>
            <div id="decks">
                <div class="deck-container">
                    <div class="deck-label">Spell Deck</div>
                    <div class="deck-card" data-deck-id="spell" draggable="true">0</div>
                </div>
                <div class="deck-container">
                    <div class="deck-label">Equipment Deck</div>
                    <div class="deck-card" data-deck-id="equipment" draggable="true">0</div>
                </div>
            </div>
            <div class="hand-container">
                <div id="hand" class="hand"></div>
                <div class="skill-deck-container">
                    <div class="deck-label">Skill Deck</div>
                    <div class="deck-card" id="skill-deck" data-deck-id="skill" draggable="true">0</div>
                </div>
            </div>
        </div>
        <div id="dice-container">
            <label for="dice-type">Dice Type:</label>
            <select id="dice-type">
                <option value="2d6" selected>2d6 (slot roll)</option>
                <option value="4">1d4</option>
                <option value="6">1d6</option>
                <option value="8">1d8</option>
                <option value="10">1d10</option>
            </select>
            <button id="rollDice">Roll Dice</button>
            <div id="dice-result"></div>
            <div id="roll-history"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.14.0/Sortable.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.3/dist/peerjs.min.js"></script>
    <script src="./deckImages.js"></script>
    <script>
        let peer;
        let connections = [];
        let isHost = false;
        let conn;
        const skillDeckCounts = {};
        const rollHistory = [];
        const playerInfo = [
            { id: 'player1', peerId: null, connected: false, cards: 0, lp: 40 },
            { id: 'player2', peerId: null, connected: false, cards: 0, lp: 40 },
            { id: 'player3', peerId: null, connected: false, cards: 0, lp: 40 },
            { id: 'player4', peerId: null, connected: false, cards: 0, lp: 40 }
        ];

        function updateConnectionStatus(message) {
            const connectionStatus = document.getElementById('connection-status');
            if (connectionStatus) {
                connectionStatus.textContent = 'Status: ' + message;
            }
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function loadDeckImages(deckId) {
            const images = deckImages[deckId];
            shuffle(images);
            if (deckId === 'skill') {
                document.getElementById('skill-deck').textContent = images.length;
            } else {
                document.querySelector(`.deck-card[data-deck-id='${deckId}']`).textContent = images.length;
            }
        }

        function loadAllDeckImages() {
            const deckTypes = ['spell', 'equipment', 'skill'];
            deckTypes.forEach(type => {
                loadDeckImages(type);
            });
        }

        function initializeDecks() {
            const deckTypes = ['spell', 'equipment', 'skill'];
            deckTypes.forEach(type => {
                const images = deckImages[type];
                shuffle(images);
                if (type === 'skill') {
                    document.getElementById('skill-deck').textContent = images.length;
                    skillDeckCounts[peer.id] = images.length;
                } else {
                    document.querySelector(`.deck-card[data-deck-id='${type}']`).textContent = images.length;
                }
            });
            if (isHost) {
                broadcast({ type: 'initializeDecks', deckImages });
            }
        }

        document.getElementById('startHost').addEventListener('click', () => {
            peer = new Peer();

            peer.on('open', id => {
                console.log('Host ID: ' + id);
                const hostIdDisplay = document.getElementById('hostIdDisplay');
                hostIdDisplay.textContent = 'Host ID: ' + id;
                hostIdDisplay.style.display = 'block';
                isHost = true;
                showSnackbar(`Host started with ID ${id}`);
                initializeDecks(); // Initialize decks after peer ID is available
            });

            peer.on('connection', connection => {
                console.log('Client connected');
                connections.push(connection);
                const playerIndex = connections.length - 1;
                if (playerIndex < 4) {
                    const player = playerInfo[playerIndex];
                    player.connected = true;
                    player.peerId = connection.peer;
                    updatePlayerUI(playerIndex);
                    showSnackbar(`Player ${playerIndex + 1} connected`);
                }
                connection.on('data', data => {
                    handleData(data);
                    // Broadcast to other clients
                    connections.forEach(conn => {
                        if (conn !== connection) {
                            conn.send(data);
                        }
                    });
                });
                connection.on('open', () => {
                    console.log('Connection opened with client');
                });
                connection.on('close', () => {
                    console.log('Client disconnected');
                    const player = playerInfo.find(p => p.peerId === connection.peer);
                    if (player) {
                        player.connected = false;
                        player.peerId = null;
                        updatePlayerUI(playerInfo.indexOf(player));
                        showSnackbar(`Player ${playerInfo.indexOf(player) + 1} disconnected`);
                    }
                    connections = connections.filter(conn => conn !== connection);
                });
            });

            peer.on('error', (err) => {
                console.error('PeerJS error: ', err);
                showSnackbar(`Error: ${err}`);
            });
        });

        document.getElementById('joinGame').addEventListener('click', () => {
            const hostId = document.getElementById('peerId').value;
            peer = new Peer();

            peer.on('open', () => {
                console.log('Client peer opened');
                conn = peer.connect(hostId);

                conn.on('open', () => {
                    console.log('Connected to host');
                    showSnackbar('Connected to host');
                });

                conn.on('data', handleData);

                conn.on('error', (err) => {
                    console.error('Connection error: ', err);
                    showSnackbar(`Error: ${err}`);
                });

                peer.on('error', (err) => {
                    console.error('PeerJS error: ', err);
                    showSnackbar(`Error: ${err}`);
                });
            });
        });

        function handleData(data) {
            console.log('Received data:', data);
            if (data.type === 'initializeDecks') {
                console.log('Initializing decks with data:', data.deckImages);
                Object.keys(data.deckImages).forEach(deckId => {
                    deckImages[deckId] = data.deckImages[deckId];
                    const count = deckImages[deckId].length;
                    if (deckId === 'skill') {
                        skillDeckCounts[peer.id] = count;
                        document.getElementById('skill-deck').textContent = count;
                    } else {
                        document.querySelector(`.deck-card[data-deck-id='${deckId}']`).textContent = count;
                    }
                });
            } else if (data.type === 'move') {
                const fromSlot = document.querySelector(`.slot[data-index='${data.from}']`);
                const toSlot = document.querySelector(`.slot[data-index='${data.to}']`);
                if (fromSlot && toSlot) {
                    fromSlot.innerHTML = '';
                    toSlot.innerHTML = data.item;
                }
            } else if (data.type === 'roll') {
                if (data.diceType === '2d6') {
                    highlightSlot(data.row, data.col);
                }
                addRollToHistory(data.result);
            } else if (data.type === 'drawCard') {
                console.log('Handling drawCard:', data);
                if (data.deckId === 'skill') {
                    updateSkillDeckCount(data.clientId, -1);
                } else {
                    updateDeckCount(data.deckId, -1);
                }
                // Only the client who drew the card will add it to their hand
                if (data.clientId === peer.id) {
                    addCardToHand(data.deckId, data.cardIndex);
                }
                // Update player cards count
                const player = playerInfo.find(p => p.peerId === data.clientId);
                if (player) {
                    player.cards += 1;
                    updatePlayerUI(playerInfo.indexOf(player));
                }
            } else if (data.type === 'placeCard') {
                placeCardOnBoard(data.cardId, data.slotIndex);
            } else if (data.type === 'updateDeckCount') {
                updateDeckCount(data.deckId, data.count);
            }
        }

        function broadcast(data) {
            console.log('Broadcasting data:', data);
            connections.forEach(connection => connection.send(data));
        }

        function updatePlayerUI(playerIndex) {
            const player = playerInfo[playerIndex];
            const playerSlot = document.getElementById(player.id);
            const icon = playerSlot.querySelector('.player-icon');
            const status = playerSlot.querySelector('.player-status');
            const cards = playerSlot.querySelector('.player-cards');
            const lp = playerSlot.querySelector('.player-lp');

            if (player.connected) {
                icon.src = "images/player-icon.png";
                status.textContent = 'Connected';
                cards.textContent = `Cards: ${player.cards}`;
                lp.textContent = `LP: ${player.lp}`;
            } else {
                icon.src = "images/no-player.png";
                status.textContent = 'Disconnected';
                cards.textContent = 'Cards: 0';
                lp.textContent = 'LP: 0';
            }
        }

        // Create the 6x6 board
        const board = document.getElementById('board');
        for (let i = 0; i < 36; i++) {
            const slot = document.createElement('div');
            slot.className = 'slot';
            slot.dataset.index = i;
            board.appendChild(slot);
        }

        // Initialize sortable
        Sortable.create(board, {
            animation: 150,
            group: 'shared',
            draggable: '.draggable, .card',
            onAdd: function (evt) {
                if (evt.from.id === 'hand') {
                    const cardId = evt.item.dataset.cardId;
                    const slotIndex = evt.to.dataset.index;
                    const data = { type: 'placeCard', cardId, slotIndex };
                    if (isHost) {
                        broadcast(data);
                    } else if (conn) {
                        conn.send(data);
                    }
                }
            }
        });

        // Roll dice functionality
        document.getElementById('rollDice').addEventListener('click', function() {
            const diceType = document.getElementById('dice-type').value;
            rollDice(diceType);
        });

        function rollDice(diceType) {
            const diceResult = document.getElementById('dice-result');
            diceResult.textContent = 'Rolling...';
            let rolls = 0;
            const maxRolls = 20;
            const interval = setInterval(() => {
                if (rolls >= maxRolls) {
                    clearInterval(interval);
                    let result;
                    if (diceType === '2d6') {
                        const die1 = Math.floor(Math.random() * 6) + 1;
                        const die2 = Math.floor(Math.random() * 6) + 1;
                        result = [die1, die2];
                        diceResult.textContent = `Result: (${die1}, ${die2})`;
                        highlightSlot(die1, die2);
                    } else {
                        result = Math.floor(Math.random() * diceType) + 1;
                        diceResult.textContent = `Result: (${result})`;
                    }
                    addRollToHistory(result);
                    const rollData = { type: 'roll', diceType, result };
                    if (diceType === '2d6') {
                        rollData.row = result[0];
                        rollData.col = result[1];
                    }
                    if (isHost) {
                        broadcast(rollData);
                    } else if (conn) {
                        conn.send(rollData);
                    }
                } else {
                    if (diceType === '2d6') {
                        diceResult.textContent = `Rolling... (${Math.floor(Math.random() * 6) + 1}, ${Math.floor(Math.random() * 6) + 1})`;
                    } else {
                        diceResult.textContent = `Rolling... (${Math.floor(Math.random() * diceType) + 1})`;
                    }
                    rolls++;
                }
            }, 50);
        }

        function highlightSlot(row, col) {
            const slots = document.querySelectorAll('.slot');
            slots.forEach(slot => slot.classList.remove('highlight'));
            const targetIndex = (row - 1) * 6 + (col - 1);
            const targetSlot = slots[targetIndex];
            if (targetSlot) {
                targetSlot.classList.add('highlight');
            }
        }

        function addRollToHistory(result) {
            rollHistory.unshift(result);
            const rollHistoryDiv = document.getElementById('roll-history');
            rollHistoryDiv.innerHTML = 'Roll History:<br>' + rollHistory.map(r => Array.isArray(r) ? `(${r[0]}, ${r[1]})` : `(${r})`).join('<br>');
        }

        // Initialize the decks
        const decks = document.querySelectorAll('.deck-card');
        decks.forEach(deck => {
            deck.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', deck.dataset.deckId);
            });
        });

        // Handle dropping cards into the hand
        const hand = document.getElementById('hand');
        hand.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        hand.addEventListener('drop', (e) => {
            e.preventDefault();
            const deckId = e.dataTransfer.getData('text/plain');
            console.log('Dropping card from deck:', deckId);
            if (deckId === 'skill') {
                if (!skillDeckCounts[peer.id]) {
                    skillDeckCounts[peer.id] = deckImages['skill'].length;
                }
                const count = skillDeckCounts[peer.id];
                if (count > 0) {
                    const cardIndex = deckImages[deckId].length - count; // Get the next card image index
                    updateSkillDeckCount(peer.id, -1);
                    addCardToHand(deckId, cardIndex);
                    const data = { type: 'drawCard', deckId, clientId: peer.id, cardIndex };
                    if (isHost) {
                        broadcast(data);
                    } else if (conn) {
                        conn.send(data);
                    }
                }
            } else {
                const deck = document.querySelector(`.deck-card[data-deck-id='${deckId}']`);
                const count = parseInt(deck.textContent);
                if (count > 0) {
                    const cardIndex = deckImages[deckId].length - count; // Get the next card image index
                    updateDeckCount(deckId, -1);
                    addCardToHand(deckId, cardIndex);
                    const data = { type: 'drawCard', deckId, clientId: peer.id, cardIndex };
                    if (isHost) {
                        broadcast(data);
                    } else if (conn) {
                        conn.send(data);
                    }
                }
            }
        });

        // Update deck count
        function updateDeckCount(deckId, change) {
            const deck = document.querySelector(`.deck-card[data-deck-id='${deckId}']`);
            let count = parseInt(deck.textContent);
            count += change;
            deck.textContent = count;
            if (count === 0) {
                deck.setAttribute('draggable', 'false');
                deck.style.cursor = 'not-allowed';
            } else {
                deck.setAttribute('draggable', 'true');
                deck.style.cursor = 'grab';
            }
            if (isHost) {
                const data = { type: 'updateDeckCount', deckId, count };
                broadcast(data);
            }
        }

        function updateSkillDeckCount(clientId, change) {
            if (!(clientId in skillDeckCounts)) {
                skillDeckCounts[clientId] = deckImages['skill'].length;
            }
            skillDeckCounts[clientId] += change;
            const count = skillDeckCounts[clientId];
            console.log(`Updating skill deck count for ${clientId}: ${count}`);
            if (clientId === peer.id) {
                const deck = document.getElementById('skill-deck');
                deck.textContent = count;
                if (count === 0) {
                    deck.setAttribute('draggable', 'false');
                    deck.style.cursor = 'not-allowed';
                } else {
                    deck.setAttribute('draggable', 'true');
                    deck.style.cursor = 'grab';
                }
            }
        }

        // Add a card to the hand with image
        function addCardToHand(deckId, cardIndex) {
            console.log(`Adding card to hand from ${deckId}, card index: ${cardIndex}`);
            const card = document.createElement('div');
            card.className = 'card';
            card.dataset.cardId = `deck${deckId}-${Math.random().toString(36).substr(2, 9)}`;
            const img = document.createElement('img');
            img.src = `./images/${deckId}/${deckImages[deckId][cardIndex]}`;
            card.appendChild(img);
            card.draggable = true;
            hand.appendChild(card);
        }

        // Place a card on the board
        function placeCardOnBoard(cardId, slotIndex) {
            console.log(`Placing card ${cardId} on board at slot ${slotIndex}`);
            const card = document.querySelector(`.card[data-cardId='${cardId}']`);
            const slot = document.querySelector(`.slot[data-index='${slotIndex}']`);
            if (card && slot) {
                slot.appendChild(card);
            }
        }

        // Snackbar function to show temporary notifications
        function showSnackbar(message) {
            const snackbar = document.getElementById('snackbar');
            snackbar.textContent = message;
            snackbar.className = 'show';
            setTimeout(() => {
                snackbar.className = snackbar.className.replace('show', '');
            }, 3000);
        }

        // Load decks images after page load
        document.addEventListener('DOMContentLoaded', loadAllDeckImages);
    </script>
</body>
</html>
