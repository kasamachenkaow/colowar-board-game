<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Board Game</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            position: relative;
        }
        #controls {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 10px;
        }
        button, input {
            margin: 5px;
        }
        #board-container {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-grow: 1;
            width: 100%;
        }
        #board {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            grid-template-rows: repeat(6, 1fr);
            gap: 2px;
            width: 60vh;
            height: 60vh;
        }
        .slot {
            border: 1px solid #000;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f0f0f0;
            position: relative;
        }
        .highlight {
            background-color: yellow !important;
        }
        .draggable {
            width: 90%;
            height: 90%;
            background-color: blue;
            border: 1px solid #000;
            cursor: grab;
        }
        .deck-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 10px;
        }
        .deck-label {
            margin-bottom: 5px;
            font-weight: bold;
        }
        .deck-card {
            width: 60px;
            height: 90px;
            border: 1px solid #000;
            background-color: gray;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            color: white;
            cursor: grab;
        }
        .hand-container {
            display: flex;
            align-items: center;
            margin-top: 20px;
            width: 100%;
            justify-content: center;
        }
        .hand {
            border: 1px solid #000;
            padding: 10px;
            width: 50%;
            display: flex;
            flex-wrap: wrap; /* Align cards in rows */
            justify-content: flex-start;
            min-height: 120px; /* Ensure stable height */
        }
        .card {
            width: 60px;
            height: 90px;
            border: 1px solid #000;
            background-color: white;
            margin: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
        }
        .card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        #connection-status {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px;
            border: 1px solid #000;
            background-color: white;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        #decks {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 20px;
        }
        .skill-deck-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-left: 20px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="controls">
            <button id="rollDice">Roll Dice</button>
            <div id="dice"></div>
            <button id="startHost">Start as Host</button>
            <input type="text" id="peerId" placeholder="Enter Host ID">
            <button id="joinGame">Join Game</button>
            <div id="hostIdDisplay"></div>
        </div>
        <div id="board-container">
            <div id="board"></div>
        </div>
        <div id="decks">
            <div class="deck-container">
                <div class="deck-label">Spell Deck</div>
                <div class="deck-card" data-deck-id="spell" draggable="true">0</div>
            </div>
            <div class="deck-container">
                <div class="deck-label">Equipment Deck</div>
                <div class="deck-card" data-deck-id="equipment" draggable="true">0</div>
            </div>
        </div>
        <div class="hand-container">
            <div id="hand" class="hand"></div>
            <div class="skill-deck-container">
                <div class="deck-label">Skill Deck</div>
                <div class="deck-card" id="skill-deck" data-deck-id="skill" draggable="true">0</div>
            </div>
        </div>
        <div id="connection-status">Status: Disconnected</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.14.0/Sortable.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.3/dist/peerjs.min.js"></script>
    <script src="./deckImages.js"></script>
    <script>
        let peer;
        let connections = [];
        let isHost = false;
        let conn;
        const connectionStatus = document.getElementById('connection-status');
        const skillDeckCounts = {};

        function updateConnectionStatus(message) {
            connectionStatus.textContent = 'Status: ' + message;
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function loadDeckImages(deckId) {
            const images = deckImages[deckId];
            shuffle(images);
            if (deckId === 'skill') {
                document.getElementById('skill-deck').textContent = images.length;
            } else {
                document.querySelector(`.deck-card[data-deck-id='${deckId}']`).textContent = images.length;
            }
        }

        function loadAllDeckImages() {
            const deckTypes = ['spell', 'equipment', 'skill'];
            deckTypes.forEach(type => {
                loadDeckImages(type);
            });
        }

        function initializeDecks() {
            const deckTypes = ['spell', 'equipment', 'skill'];
            deckTypes.forEach(type => {
                const images = deckImages[type];
                shuffle(images);
                if (type === 'skill') {
                    document.getElementById('skill-deck').textContent = images.length;
                    skillDeckCounts[peer.id] = images.length;
                } else {
                    document.querySelector(`.deck-card[data-deck-id='${type}']`).textContent = images.length;
                }
            });
            if (isHost) {
                broadcast({ type: 'initializeDecks', deckImages });
            }
        }

        document.getElementById('startHost').addEventListener('click', () => {
            peer = new Peer();

            peer.on('open', id => {
                console.log('Host ID: ' + id);
                const hostIdDisplay = document.getElementById('hostIdDisplay');
                hostIdDisplay.textContent = 'Host ID: ' + id;
                hostIdDisplay.style.display = 'block';
                isHost = true;
                updateConnectionStatus('Host started with ID ' + id);
                initializeDecks(); // Initialize decks after peer ID is available
            });

            peer.on('connection', connection => {
                console.log('Client connected');
                connections.push(connection);
                connection.on('data', data => {
                    handleData(data);
                    // Broadcast to other clients
                    connections.forEach(conn => {
                        if (conn !== connection) {
                            conn.send(data);
                        }
                    });
                });
                connection.on('open', () => {
                    console.log('Connection opened with client');
                    updateConnectionStatus('Client connected');
                });
                connection.on('close', () => {
                    console.log('Client disconnected');
                    connections = connections.filter(conn => conn !== connection);
                    updateConnectionStatus('Client disconnected');
                });
            });

            peer.on('error', (err) => {
                console.error('PeerJS error: ', err);
                updateConnectionStatus('Error: ' + err);
            });
        });

        document.getElementById('joinGame').addEventListener('click', () => {
            const hostId = document.getElementById('peerId').value;
            peer = new Peer();

            peer.on('open', () => {
                console.log('Client peer opened');
                conn = peer.connect(hostId);

                conn.on('open', () => {
                    console.log('Connected to host');
                    updateConnectionStatus('Connected to host');
                });

                conn.on('data', handleData);

                conn.on('error', (err) => {
                    console.error('Connection error: ', err);
                    updateConnectionStatus('Error: ' + err);
                });

                peer.on('error', (err) => {
                    console.error('PeerJS error: ', err);
                    updateConnectionStatus('Error: ' + err);
                });
            });
        });

        function handleData(data) {
            console.log('Received data:', data);
            if (data.type === 'initializeDecks') {
                console.log('Initializing decks with data:', data.deckImages);
                Object.keys(data.deckImages).forEach(deckId => {
                    deckImages[deckId] = data.deckImages[deckId];
                    const count = deckImages[deckId].length;
                    if (deckId === 'skill') {
                        skillDeckCounts[peer.id] = count;
                        document.getElementById('skill-deck').textContent = count;
                    } else {
                        document.querySelector(`.deck-card[data-deck-id='${deckId}']`).textContent = count;
                    }
                });
            } else if (data.type === 'move') {
                const fromSlot = document.querySelector(`.slot[data-index='${data.from}']`);
                const toSlot = document.querySelector(`.slot[data-index='${data.to}']`);
                if (fromSlot && toSlot) {
                    fromSlot.innerHTML = '';
                    toSlot.innerHTML = data.item;
                }
            } else if (data.type === 'roll') {
                highlightSlot(data.row, data.col);
            } else if (data.type === 'drawCard') {
                console.log('Handling drawCard:', data);
                if (data.deckId === 'skill') {
                    updateSkillDeckCount(data.clientId, -1);
                } else {
                    updateDeckCount(data.deckId, -1);
                }
                // Only the client who drew the card will add it to their hand
                if (data.clientId === peer.id) {
                    addCardToHand(data.deckId, data.cardIndex);
                }
            } else if (data.type === 'placeCard') {
                placeCardOnBoard(data.cardId, data.slotIndex);
            } else if (data.type === 'updateDeckCount') {
                updateDeckCount(data.deckId, data.count);
            }
        }

        function broadcast(data) {
            console.log('Broadcasting data:', data);
            connections.forEach(connection => connection.send(data));
        }

        // Create the 6x6 board
        const board = document.getElementById('board');
        for (let i = 0; i < 36; i++) {
            const slot = document.createElement('div');
            slot.className = 'slot';
            slot.dataset.index = i;
            board.appendChild(slot);
        }

        // Initialize sortable
        Sortable.create(board, {
            animation: 150,
            group: 'shared',
            draggable: '.draggable, .card',
            onAdd: function (evt) {
                if (evt.from.id === 'hand') {
                    const cardId = evt.item.dataset.cardId;
                    const slotIndex = evt.to.dataset.index;
                    const data = { type: 'placeCard', cardId, slotIndex };
                    if (isHost) {
                        broadcast(data);
                    } else if (conn) {
                        conn.send(data);
                    }
                }
            }
        });

        // Roll dice functionality
        document.getElementById('rollDice').addEventListener('click', function() {
            const rowDice = Math.floor(Math.random() * 6) + 1;
            const colDice = Math.floor(Math.random() * 6) + 1;
            document.getElementById('dice').textContent = `Rolled: Row = ${rowDice}, Column = ${colDice}`;

            highlightSlot(rowDice, colDice);

            const rollData = { type: 'roll', row: rowDice, col: colDice };

            if (isHost) {
                broadcast(rollData);
            } else if (conn) {
                conn.send(rollData);
            }
        });

        function highlightSlot(row, col) {
            const slots = document.querySelectorAll('.slot');
            slots.forEach(slot => slot.classList.remove('highlight'));
            const targetIndex = (row - 1) * 6 + (col - 1);
            const targetSlot = slots[targetIndex];
            if (targetSlot) {
                targetSlot.classList.add('highlight');
            }
        }

        // Initialize the decks
        const decks = document.querySelectorAll('.deck-card');
        decks.forEach(deck => {
            deck.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', deck.dataset.deckId);
            });
        });

        // Handle dropping cards into the hand
        const hand = document.getElementById('hand');
        hand.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        hand.addEventListener('drop', (e) => {
            e.preventDefault();
            const deckId = e.dataTransfer.getData('text/plain');
            console.log('Dropping card from deck:', deckId);
            if (deckId === 'skill') {
                if (!skillDeckCounts[peer.id]) {
                    skillDeckCounts[peer.id] = deckImages['skill'].length;
                }
                const count = skillDeckCounts[peer.id];
                if (count > 0) {
                    const cardIndex = deckImages[deckId].length - count; // Get the next card image index
                    updateSkillDeckCount(peer.id, -1);
                    addCardToHand(deckId, cardIndex);
                    const data = { type: 'drawCard', deckId, clientId: peer.id, cardIndex };
                    if (isHost) {
                        broadcast(data);
                    } else if (conn) {
                        conn.send(data);
                    }
                }
            } else {
                const deck = document.querySelector(`.deck-card[data-deck-id='${deckId}']`);
                const count = parseInt(deck.textContent);
                if (count > 0) {
                    const cardIndex = deckImages[deckId].length - count; // Get the next card image index
                    updateDeckCount(deckId, -1);
                    addCardToHand(deckId, cardIndex);
                    const data = { type: 'drawCard', deckId, clientId: peer.id, cardIndex };
                    if (isHost) {
                        broadcast(data);
                    } else if (conn) {
                        conn.send(data);
                    }
                }
            }
        });

        // Update deck count
        function updateDeckCount(deckId, change) {
            const deck = document.querySelector(`.deck-card[data-deck-id='${deckId}']`);
            let count = parseInt(deck.textContent);
            count += change;
            deck.textContent = count;
            if (count === 0) {
                deck.setAttribute('draggable', 'false');
                deck.style.cursor = 'not-allowed';
            } else {
                deck.setAttribute('draggable', 'true');
                deck.style.cursor = 'grab';
            }
            if (isHost) {
                const data = { type: 'updateDeckCount', deckId, count };
                broadcast(data);
            }
        }

        function updateSkillDeckCount(clientId, change) {
            if (!(clientId in skillDeckCounts)) {
                skillDeckCounts[clientId] = deckImages['skill'].length;
            }
            skillDeckCounts[clientId] += change;
            const count = skillDeckCounts[clientId];
            console.log(`Updating skill deck count for ${clientId}: ${count}`);
            if (clientId === peer.id) {
                const deck = document.getElementById('skill-deck');
                deck.textContent = count;
                if (count === 0) {
                    deck.setAttribute('draggable', 'false');
                    deck.style.cursor = 'not-allowed';
                } else {
                    deck.setAttribute('draggable', 'true');
                    deck.style.cursor = 'grab';
                }
            }
        }

        // Add a card to the hand with image
        function addCardToHand(deckId, cardIndex) {
            console.log(`Adding card to hand from ${deckId}, card index: ${cardIndex}`);
            const card = document.createElement('div');
            card.className = 'card';
            card.dataset.cardId = `deck${deckId}-${Math.random().toString(36).substr(2, 9)}`;
            const img = document.createElement('img');
            img.src = `./images/${deckId}/${deckImages[deckId][cardIndex]}`;
            card.appendChild(img);
            card.draggable = true;
            hand.appendChild(card);
        }

        // Place a card on the board
        function placeCardOnBoard(cardId, slotIndex) {
            console.log(`Placing card ${cardId} on board at slot ${slotIndex}`);
            const card = document.querySelector(`.card[data-cardId='${cardId}']`);
            const slot = document.querySelector(`.slot[data-index='${slotIndex}']`);
            if (card && slot) {
                slot.appendChild(card);
            }
        }

        // Load decks images after page load
        document.addEventListener('DOMContentLoaded', loadAllDeckImages);
    </script>
</body>
</html>
